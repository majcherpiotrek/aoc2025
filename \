package day_05

import (
	"fmt"
	"strconv"
	"strings"
)

type IdRange struct {
	Min   int64
	Max   int64
	Right *IdRange
	Left  *IdRange
}

func (idr IdRange) insert(rangeStart int64, rangeEnd int64) {
	fmt.Printf("Inserting range %d, %d into %d, %d\n", rangeStart, rangeEnd, idr.Min, idr.Max)
	// Contained within current range
	if rangeStart >= idr.Min && rangeEnd <= idr.Max {
		fmt.Printf("Contained within, returning...\n")
		return
	}

	// Lower range
	if rangeEnd <= idr.Min {
		fmt.Printf("Lower range\n")
		if idr.Left != nil {
			fmt.Printf("Inserting new lower range\n")
			if rangeStart >= idr.Left.Max {
				newRange := IdRange{
					Min:   rangeStart,
					Max:   rangeEnd,
					Left:  idr.Left,
					Right: &idr,
				}

				idr.Left.Right = &newRange
				idr.Left = &newRange
			} else {
				idr.Left.insert(rangeStart, idr.Left.Max)
				idr.Left.insert(idr.Left.Max, rangeEnd)
			}
		} else {
			idr.Left = &IdRange{
				Min:   rangeStart,
				Max:   rangeEnd,
				Right: &idr,
				Left:  nil,
			}
		}
		return
	}

	// Higher range
	if rangeStart >= idr.Max {
		if idr.Right != nil {
			if rangeEnd <= idr.Right.Min {
				newRange := IdRange{
					Min:   rangeStart,
					Max:   rangeEnd,
					Left:  &idr,
					Right: idr.Right,
				}

				idr.Right.Left = &newRange
				idr.Right = &newRange
			} else {
				idr.Right.insert(rangeStart, idr.Right.Min)
				idr.Right.insert(idr.Right.Min, rangeEnd)
			}
		} else {
			idr.Right = &IdRange{
				Min:   rangeStart,
				Max:   rangeEnd,
				Right: nil,
				Left:  &idr,
			}
		}
		return
	}

	if rangeStart < idr.Min {
		if idr.Left != nil {
			idr.Left.insert(rangeStart, idr.Min)
		} else {
			idr.Min = rangeStart
		}
		return
	}

	if rangeEnd > idr.Max {
		if idr.Right != nil {
			idr.Right.insert(idr.Max, rangeEnd)
		} else {
			idr.Max = rangeEnd
		}
		return
	}

}

func (idr IdRange) printTree() {
	next := &idr

	for next.Left != nil {
		next = next.Left
	}

	fmt.Printf("from %d to %d\n", next.Min, next.Max)

	for next.Right != nil {
		next = next.Right
		fmt.Printf("from %d to %d\n", next.Min, next.Max)
	}
}

func parseInput(input *[]string) (*IdRange, []int64, error) {
	parseRanges := true
	var freshIds *IdRange
	ids := make([]int64, 0)

	for i, row := range *input {
		if len(row) == 0 {
			parseRanges = false
			continue
		}

		if parseRanges {
			rangeStr := strings.Split(row, "-")

			if len(rangeStr) != 2 {
				return nil, []int64{}, fmt.Errorf("invalid input row %d - range of ids expected, received %s", i, row)
			}

			rangeStart, err := strconv.Atoi(rangeStr[0])
			if err != nil {
				return nil, []int64{}, err
			}
			rangeEnd, err := strconv.Atoi(rangeStr[1])
			if err != nil {
				return nil, []int64{}, err
			}

			if freshIds != nil {
				freshIds.insert(int64(rangeStart), int64(rangeEnd))
			} else {
				freshIds = &IdRange{
					Min:   int64(rangeStart),
					Max:   int64(rangeEnd),
					Left:  nil,
					Right: nil,
				}
			}

		} else {
			id, err := strconv.Atoi(row)
			if err != nil {
				return nil, []int64{}, err
			}

			ids = append(ids, int64(id))
		}
	}

	return freshIds, ids, nil
}

func Part1(input *[]string) (int, error) {
	freshIds, _, err := parseInput(input)

	if err != nil {
		return -1, err
	}

	if freshIds == nil {
		return -1, fmt.Errorf("no fresh id ranges")
	}

	freshIds.printTree()

	return -1, nil
}

func Part2(input *[]string) (int, error) {

	return -1, fmt.Errorf("")
}
